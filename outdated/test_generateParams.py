import numpy as np
import pandas as pd
from SALib.sample import latin
import Settings_COVID_Dx


#Unpack conditions from Settings.py
conditions_dictionary, initial_params_dictionary, data_dictionary = Settings_COVID_Dx.init()
model = conditions_dictionary["model"] 
data = conditions_dictionary["data"]
problem_free = conditions_dictionary["problem"]
n_search = conditions_dictionary["n_search"]
fit_params = problem_free['names']
bounds = problem_free['bounds']
num_vars = problem_free['num_vars']
p_all = conditions_dictionary["p_all"] 
real_param_labels_all = conditions_dictionary["real_param_labels_all"] 
num_datasets_pem_eval = conditions_dictionary["num_datasets_pem_eval"] 
problem_all_params = conditions_dictionary["problem_all_params"]
all_param_labels = problem_all_params['names']
param_labels = list(initial_params_dictionary.keys())
init_params = list(initial_params_dictionary.values())
real_param_labels_free = conditions_dictionary["real_param_labels_free"]


def generateParams(problem, n_search, parameters, problem_all_params, model, data):
    ''' 
    Purpose: Generate parameter sets for global search 
        
    Inputs: 
        problem: a dictionary including the number, labels, and bounds for the free parameters 
            (defined in Settings.py)
            
        n_Search: the total number of parameter sets in the global search
        
        parameters: a list of initial guesses  for each parameter (length equal to number of 
            free parameters, labels based on thse defined in Settings.py)
        
        problem_all_params: a dictionary including the number, labels, and bounds for all 
            potentially free parameters (defined in Settings.py), even if the parameter is not free 
            in this specific simulation
       
        model: a string that defines the model identity
        
        data: a string that defines the data identity
           
    Outputs:
        df_params: a dataframe with columns corresponding to parameter identities 
            (# columns = # parameters) and rows corresponding to parameter values 
            (# rows = # parameter sets)
          
    Files: 
        PARAM SWEEP.xlsx (dataframe df_params from output)
    '''
  
    #Define specific conditions from the dictionaries
    fit_params = problem['names'] #only the currently free parameters (as set in settings)
    num_params = problem['num_vars']
    all_params = problem_all_params['names'] #all params that are potentially free 
    
    #Create an empty dataframe to store results of the parameter sweep
    df_params = pd.DataFrame()

    #Fill each column of the dataframe with the intial values set in Settings. 
    for item in range(0, len(all_params)):
        param = all_params[item]
        param_array = np.full((1, n_search), parameters[item])
        param_array = param_array.tolist()
        df_params[param] = param_array[0]
    
    #Perform LHS
    param_values = latin.sample(problem, n_search, seed=456767) #og seed= 456767, seed2 = 123, seed3 = 654, seed4 = 8352
    
    #To sample parameters over a log scale, we sample the exponent space and then 
    #transform the values following LHS.
    #Each parameter x generated by the search method is transformed such that the new 
    #parameter to be fed into the model = 10^x
    params_converted = []
    for item in param_values:
        item1 = [10**(val) for val in item]
        params_converted.append(item1)
    params_converted = np.asarray(params_converted)

    #Replace the column of each fit parameter with the list of parameters from the sweep
    for item in range(0, num_params):   
        for name in fit_params:
            if fit_params[item] == name:
                df_params[name] = params_converted[:,item]
    

    for index, row in df_params.iterrows():
        np.random.seed(index)
        b_val = df_params.at[index, 'p6']
        lower_bound = -((b_val-2)*0.05 + 1)/(0.05-1)
        upper_bound = -((b_val-2)*0.2 + 1)/(0.2-1)
        a_bounded = np.random.uniform(low=lower_bound, high=upper_bound, size=1)
        df_params.at[index, 'p5'] = a_bounded
    print(df_params)
    #add model, names, bounds to df
    m_ = np.full((1, n_search), model)
    m_array = m_.tolist()
    df_params['model'] =  m_array[0]
    
    names = [problem['names']] * n_search
    df_params['names'] =  names
      
    bounds= [problem['bounds']] * n_search
    df_params['bounds'] =  bounds

    #Save df
    filename = './PARAM SWEEP.xlsx'
    with pd.ExcelWriter(filename) as writer:  # doctest: +SKIP
        df_params.to_excel(writer, sheet_name='GSA params')
    
    return df_params


df_params = generateParams(problem_free, n_search, p_all, problem_all_params, model, data)